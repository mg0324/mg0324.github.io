<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 程序猫大刚</title><link>/mb/tags/java/</link><description>Recent content in java on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 28 Jul 2022 10:42:57 +0800</lastBuildDate><atom:link href="/mb/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>并发模式之异步回调Future模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 10:42:57 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</guid><description>Future模式（异步获取结果，自实现） 传统串行流程如下： 在获取数据时会阻塞等待，拿到数据后再执行其他的任务。 而Future模式会立即返回一个凭证（Future），这时可以执行其他任务；等需要数据再通</description></item><item><title>并发模式之生产者消费者模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:54:19 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>生产者 - 消费者模式 生产者消费者模式是一个经典的多线程设计模式。 总结： 生产者线程将任务提交到内存缓冲区，消费者线程从内存缓冲区获取任务并执行。 通过内存缓冲区，避免了生成者和消费者直接通信，从而将生产者和</description></item><item><title>并发模式之单例和不变模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:53:21 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式是为了确保系统中某个类只存在一个实例。 在多种写法中，推荐使用静态内部类方式，利用类加载一次特性确保只有一个实例（线程安全）， 同时具备无锁和懒创建优点。 示例： public class StaticInnerClassSingleton { // 私有化构造方法 private StaticInnerClassSingleton(){}</description></item><item><title>Java关键字synchronized</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</link><pubDate>Sun, 24 Jul 2022 00:10:19 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</guid><description>提纲 定义 synchronized是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。 特性 因为在synchronized同步块内，只有一个线程能访问，因此确保了同步块内的</description></item><item><title>Java的线程实现</title><link>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 20 Jul 2022 22:09:06 +0800</pubDate><guid>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</guid><description>Java线程是如何实现的？ 当我们追踪Java线程的实现时，可以发现Thread类的start方法最后会运行一个start0方法，而这个方法是native的，也就是交由JDK来实现的（JDK会屏蔽调底层</description></item><item><title>Java关键字之volatile</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</link><pubDate>Tue, 19 Jul 2022 23:28:21 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</guid><description>提纲 定义 语义上，volatile是表示易变的、不确定的。 功能上，是Java提供的最轻量级的同步机制。 前因：从CPU缓存架构类比JMM线程工作内存和主内存关系 要弄懂如何保证可见性的，请看下图，左侧是CP</description></item><item><title>Java多线程同步控制方法</title><link>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 17 Jul 2022 16:44:52 +0800</pubDate><guid>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</guid><description>关键字Synchronized 关键字Synchronized、Object.wat()和Object.notify()是在jdk1.5之前用的多线程同步控制的方式，jdk1.5之后就提供了如下的jav</description></item><item><title>并行程序基础</title><link>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 11 Jul 2022 11:49:35 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid><description>程序、进程、线程 线程的生命周期 线程的状态图 线程的基本操作 线程组 守护线程 优先级 参考文档 书籍：葛一鸣 *《Java高并发程序设计第二版》</description></item><item><title>深入类加载机制</title><link>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 08 Jul 2022 12:16:51 +0800</pubDate><guid>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>类的生命周期 加载 验证 文件格式验证，元数据验证（语义校验），字节码验证（逻辑校验），符号引用校验 准备 为类变量(static的）分配内存并赋初始值。 解析 主要针对： 类或接口：CONSTANT_Class_i</description></item><item><title>初识Java内存模型JMM</title><link>/mb/post/juc/%E5%88%9D%E8%AF%86Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</link><pubDate>Wed, 06 Jul 2022 11:22:04 +0800</pubDate><guid>/mb/post/juc/%E5%88%9D%E8%AF%86Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</guid><description>原子性、可见性、有序性 什么是指令重排，为什么需要？ 要搞懂指令重排，首先要知道一条指令在CPU内是如何执行的，如下图约5个步骤。 为了加快指令并行速度，CPU硬件支持了流水线技术。 不同的指令步骤执行在不同</description></item><item><title>走入并行的世界</title><link>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 01 Jul 2022 10:33:34 +0800</pubDate><guid>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>走入并行的世界 这该死的并行 摩尔定律发展 一些基本概念 同步 vs 异步 并发 vs 并行 临界区 多个线程的公共资源，或者说共享数据。 阻塞 vs 非阻塞 死锁、饥饿、活锁 并发级别 并行加速比公式 参考文档 书籍：葛一鸣 *《Java高并发</description></item><item><title>线程池入门到精通</title><link>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</link><pubDate>Tue, 28 Jun 2022 16:38:30 +0800</pubDate><guid>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</guid><description>什么是线程池 复用创建好的线程，节约创建和销毁的时间。 需要使用线程时，就从池子里拿一个空闲的线程，完成工作后，归还线程给线程池。 线程池工作原理 线程池工作流程 线程池生命周期及扩展点 线程池参数 JDK提供的线</description></item><item><title>Java本地方法调用</title><link>/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</link><pubDate>Tue, 24 May 2022 23:08:25 +0800</pubDate><guid>/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</guid><description>引子 Class.forName(&amp;quot;com.msql.jdbc.Driver&amp;quot;); 我们在加载mysql的jdbc驱动时，会主动加载对应的驱动类，然后使用DriverManager来获取连接操作数据库。 跟进forName的实现会发现是调用的native方法来实现的，也就是JNI</description></item><item><title>发布jar包公共maven仓库</title><link>/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</link><pubDate>Sat, 25 Dec 2021 22:18:49 +0800</pubDate><guid>/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</guid><description>起因 自己写了个简单的框架，想要发布到公共的maven仓库上，方便自己引用，也给其他开发者创造一个轮子。 参考鸣谢 流程 https://blog.csdn.net/qq_36838191/article/details/81027586 操作 https://www.cnblogs.com/newsea/p/11604171.html 几个地址 工单管理: https://issues.sonatype.org 构件仓库: https://oss.sonatype.org/#welcome 仓库镜像: http://search.maven.org/ 发布流程 创建工单 发布jar包 审核通</description></item><item><title>从何而来之Java NIO</title><link>/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</link><pubDate>Wed, 13 Oct 2021 22:29:37 +0000</pubDate><guid>/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</guid><description>缘起 最近在看《Java NIO》这本书，书中详细讲解了jdk1.4内提供的关于实现nio的API。因为阅读后，发现对于NIO还是学习的不够深入，之前也仅仅是学习了Java的文件IO和Socket编程，再</description></item><item><title>Java临时文件删除时注意的坑</title><link>/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link><pubDate>Tue, 05 Jan 2021 18:56:13 +0000</pubDate><guid>/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid><description>前言 最近在生产环境上发现了临时目录堆积吃掉大量磁盘的问题，最终原因是代码有Bug，异常后未执行delete file的代码或者执行了，但是删除失败。 解决思路 将删除文件的代码放到finally块中。 确保删</description></item><item><title>java之future异步并发体验</title><link>/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 11:36:48 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.mango.demo; import cn.hutool.http.HttpUtil; import com.google.common.collect.Lists; import com.google.common.util.concurrent.ListenableFuture; import com.google.common.util.concurrent.ListeningExecutorService; import com.google.common.util.concurrent.MoreExecutors; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.stream.Collectors;</description></item><item><title>java之forkjoin体验</title><link>/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 10:52:37 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码！ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.mango.forkjoin; import cn.hutool.http.HttpUtil; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.RecursiveTask; public class ServiceTask extends RecursiveTask&amp;lt;String&amp;gt; { private String url; public ServiceTask(String url){ this.url = url; } @Override protected String compute() { String result</description></item><item><title>java之深入jvm之路</title><link>/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</link><pubDate>Sat, 14 Dec 2019 14:45:07 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</guid><description>1.仔细看一看java 1.1.java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaB</description></item><item><title>java日志门面</title><link>/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</link><pubDate>Sat, 14 Dec 2019 13:44:06 +0000</pubDate><guid>/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</guid><description>1.slf4j是什么 slf4j全称为Simple Logging Facade for Java ,即java简单日志门面，渐渐地替换调了apache common logging。 The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time. 理</description></item><item><title>Java性能注意点</title><link>/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</link><pubDate>Fri, 04 Nov 2016 15:56:32 +0000</pubDate><guid>/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</guid><description>参考：http://www.importnew.com/16181.html 1.stringBuilder.append 比 + 号的性能要优。 2.要避免使用正则表达式。 3.避免使用iterator迭代器来循环。尽量使用基本循环和增强for循环。 4</description></item></channel></rss>