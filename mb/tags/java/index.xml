<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 程序猫大刚</title><link>/mb/tags/java/</link><description>Recent content in java on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 01 Sep 2022 18:45:53 +0800</lastBuildDate><atom:link href="/mb/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>HotSpot垃圾算法实现之记忆集与卡表和写屏障</title><link>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C/</link><pubDate>Thu, 01 Sep 2022 18:45:53 +0800</pubDate><guid>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C/</guid><description>ceshi 问题一：对象跨代（区域）引用，GC Roots扫描范围如何界定？ 当部分区域进行垃圾收集时，如果非收集区域的对象跨区引用了收集区域的对象（收集区域的对象A可能被非收集区域的对象静态字段B引用，这样对象A</description></item><item><title>HotSpot垃圾算法实现之枚举根节点和安全点安全区域</title><link>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E7%82%B9%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/</link><pubDate>Thu, 01 Sep 2022 18:37:32 +0800</pubDate><guid>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E7%82%B9%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/</guid><description>在根可达性分析算法中，从GC Roots集合中找引用链是虚拟机高效实现的第一个例子。 问题一：为什么要枚举根节点？怎么高效实现？ 虽然GC Roots的节点主要在全局性的引用（例如常量或者类静态变量）与执行上</description></item><item><title>类加载器</title><link>/mb/post/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Thu, 01 Sep 2022 18:21:53 +0800</pubDate><guid>/mb/post/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>定义 Java虚拟机通过一个类的全限定名来获取类的二进制字节流的这个动作，放到虚拟机外部实现，让应用程序自己决定如何获取所需的类。 实现这个动作的代码叫做类加载器。 类与类加载器 每个类加载器都有自己独立的类</description></item><item><title>熟悉Java类文件class结构</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89Java%E7%B1%BB%E6%96%87%E4%BB%B6class%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 01 Sep 2022 00:27:48 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89Java%E7%B1%BB%E6%96%87%E4%BB%B6class%E7%BB%93%E6%9E%84/</guid><description>Java基于Class文件作为存储格式，不同平台对应虚拟机实现的方式让Java具备跨平台的特性。 因此我们有必要更深入学习Class字节码文件的结构。 Class文件的结构 Class文件是一组以8个字节为</description></item><item><title>熟悉JVM字节码指令</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 01 Sep 2022 00:19:31 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</guid><description>简介 Java虚拟机的指令由一个字节长度（256个操作码）的、代表着特定操作含义的数字（操作码，Opcode）和跟随其后的零至多个代表其操作需要的参数（操作数，Operand）构成。 由于Java虚拟机采</description></item><item><title>MacOs10.15.7编译openjdk8u</title><link>/mb/post/jvm/MacOs10_15_7%E7%BC%96%E8%AF%91openjdk8u/</link><pubDate>Mon, 22 Aug 2022 22:40:21 +0800</pubDate><guid>/mb/post/jvm/MacOs10_15_7%E7%BC%96%E8%AF%91openjdk8u/</guid><description>Mac10.15.7上编译OpenJDK8u 机器环境及依赖 操作系统：macOs 10.15.7 BootJDK: /Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home XCode：Version 11.3.1 (11C505) hg命令(mercurial): brew install mercurial freetype: brew install freetype 注意：笔者先前打算编译jdk8，一番折腾</description></item><item><title>内存分配与回收策略</title><link>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</link><pubDate>Sat, 20 Aug 2022 10:36:03 +0800</pubDate><guid>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</guid><description>前提环境 笔者JDK版本如下，如果不做指定的话，64为虚拟机1.8版本默认使用的ParallelGC垃圾收集器。 $ java -XX:+PrintCommandLineFlags -version -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version &amp;quot;1.8.0_221&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 使用-XX:+UseSerialG</description></item><item><title>垃圾收集算法</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 20 Aug 2022 10:22:08 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</guid><description>分代收集理论 3个假说 弱分代假说：绝大多数对象都是朝生夕灭的。（设计了年轻代） 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。（设计了老年代） 跨代引用假说：跨代引用相对于同代引用仅占极少数。（实际</description></item><item><title>虚拟机相关工具</title><link>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 20 Aug 2022 09:40:53 +0800</pubDate><guid>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</guid><description>本文主要是为了介绍虚拟机相关的工具，包括故障处理、性能监控和一些其他工具。 故障处理工具 名称 全称 作用及描述 jps JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool 用于收集HotSpot虚拟机各方</description></item><item><title>回收堆和方法区中对象</title><link>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 12 Aug 2022 10:54:26 +0800</pubDate><guid>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，知道了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>Java发展历史</title><link>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</link><pubDate>Fri, 12 Aug 2022 10:30:06 +0800</pubDate><guid>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</guid><description>Java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaBeans，RMI。 1998年1</description></item><item><title>垃圾判定算法与4大引用</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</link><pubDate>Wed, 10 Aug 2022 22:13:41 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，指出了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>如何计算Java对象的大小</title><link>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</link><pubDate>Tue, 09 Aug 2022 18:11:01 +0800</pubDate><guid>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</guid><description>关键点 Java对象的布局结构 借助jol-core包来打印对象 引用的指针压缩 对象布局 Java对象布局（Java Object Layout） String对象例子 int[]数组对象例子 引用的指针压缩 JVM内存寻址最大内</description></item><item><title>熟悉HotSpot中的对象</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</link><pubDate>Tue, 09 Aug 2022 17:50:54 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</guid><description>对象的内存布局 在HotSpot虚拟机中，对象的内存布局分为以下3个区域： 对象头 实例数据 对齐填充 对象头 对象头包含Mark Word和类型指针2个部分。如果是数组对象，则有一部分存储数组的长度。 Mark Word中</description></item><item><title>并发模式之异步回调Future模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 10:42:57 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</guid><description>Future模式（异步获取结果，自实现） 传统串行流程如下： 在获取数据时会阻塞等待，拿到数据后再执行其他的任务。 而Future模式会立即返回一个凭证（Future），这时可以执行其他任务；等需要数据再通</description></item><item><title>并发模式之生产者消费者模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:54:19 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>生产者 - 消费者模式 生产者消费者模式是一个经典的多线程设计模式。 总结： 生产者线程将任务提交到内存缓冲区，消费者线程从内存缓冲区获取任务并执行。 通过内存缓冲区，避免了生成者和消费者直接通信，从而将生产者和</description></item><item><title>并发模式之单例和不变模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:53:21 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式是为了确保系统中某个类只存在一个实例。 在多种写法中，推荐使用静态内部类方式，利用类加载一次特性确保只有一个实例（线程安全）， 同时具备无锁和懒创建优点。 示例： public class StaticInnerClassSingleton { // 私有化构造方法 private StaticInnerClassSingleton(){}</description></item><item><title>Java关键字synchronized</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</link><pubDate>Sun, 24 Jul 2022 00:10:19 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</guid><description>提纲 定义 synchronized是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。 特性 因为在synchronized同步块内，只有一个线程能访问，因此确保了同步块内的</description></item><item><title>Java的线程实现</title><link>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 20 Jul 2022 22:09:06 +0800</pubDate><guid>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</guid><description>Java线程是如何实现的？ 当我们追踪Java线程的实现时，可以发现Thread类的start方法最后会运行一个start0方法，而这个方法是native的，也就是交由JDK来实现的（JDK会屏蔽调底层</description></item><item><title>Java关键字之volatile</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</link><pubDate>Tue, 19 Jul 2022 23:28:21 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</guid><description>提纲 定义 语义上，volatile是表示易变的、不确定的。 功能上，是Java提供的最轻量级的同步机制。 前因：从CPU缓存架构类比JMM线程工作内存和主内存关系 要弄懂如何保证可见性的，请看下图，左侧是CP</description></item><item><title>Java多线程同步控制方法</title><link>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 17 Jul 2022 16:44:52 +0800</pubDate><guid>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</guid><description>关键字Synchronized 关键字Synchronized、Object.wat()和Object.notify()是在jdk1.5之前用的多线程同步控制的方式，jdk1.5之后就提供了如下的jav</description></item><item><title>并行程序基础</title><link>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 11 Jul 2022 11:49:35 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid><description>程序、进程、线程 线程的生命周期 线程的状态图 线程的基本操作 线程组 守护线程 优先级 参考文档 书籍：葛一鸣 *《Java高并发程序设计第二版》</description></item><item><title>深入类加载机制</title><link>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 08 Jul 2022 12:16:51 +0800</pubDate><guid>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>类的生命周期 加载 验证 文件格式验证，元数据验证（语义校验），字节码验证（逻辑校验），符号引用校验 准备 为类变量(static的）分配内存并赋初始值。 解析 主要针对： 类或接口：CONSTANT_Class_i</description></item><item><title>熟悉Java内存模型JMM</title><link>/mb/post/juc/%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</link><pubDate>Wed, 06 Jul 2022 11:22:04 +0800</pubDate><guid>/mb/post/juc/%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</guid><description>Java内存模型规范（JSR-133）是围绕原子性、可见性和有序性展开的。 原子性、可见性、有序性 如下图说明了Java线程、工作内存和主存之前的关系。 Java内存模型（JMM）定义了一套自己的主存到工作</description></item><item><title>走入并行的世界</title><link>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 01 Jul 2022 10:33:34 +0800</pubDate><guid>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>走入并行的世界 这该死的并行 摩尔定律发展 一些基本概念 同步 vs 异步 并发 vs 并行 临界区 多个线程的公共资源，或者说共享数据。 阻塞 vs 非阻塞 死锁、饥饿、活锁 并发级别 并行加速比公式 参考文档 书籍：葛一鸣 *《Java高并发</description></item><item><title>线程池入门到精通</title><link>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</link><pubDate>Tue, 28 Jun 2022 16:38:30 +0800</pubDate><guid>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</guid><description>什么是线程池 复用创建好的线程，节约创建和销毁的时间。 需要使用线程时，就从池子里拿一个空闲的线程，完成工作后，归还线程给线程池。 线程池工作原理 线程池工作流程 线程池生命周期及扩展点 线程池参数 JDK提供的线</description></item><item><title>Java本地方法调用</title><link>/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</link><pubDate>Tue, 24 May 2022 23:08:25 +0800</pubDate><guid>/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</guid><description>引子 Class.forName(&amp;quot;com.msql.jdbc.Driver&amp;quot;); 我们在加载mysql的jdbc驱动时，会主动加载对应的驱动类，然后使用DriverManager来获取连接操作数据库。 跟进forName的实现会发现是调用的native方法来实现的，也就是JNI</description></item><item><title>发布jar包公共maven仓库</title><link>/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</link><pubDate>Sat, 25 Dec 2021 22:18:49 +0800</pubDate><guid>/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</guid><description>起因 自己写了个简单的框架，想要发布到公共的maven仓库上，方便自己引用，也给其他开发者创造一个轮子。 参考鸣谢 流程 https://blog.csdn.net/qq_36838191/article/details/81027586 操作 https://www.cnblogs.com/newsea/p/11604171.html 几个地址 工单管理: https://issues.sonatype.org 构件仓库: https://oss.sonatype.org/#welcome 仓库镜像: http://search.maven.org/ 发布流程 创建工单 发布jar包 审核通</description></item><item><title>从何而来之Java NIO</title><link>/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</link><pubDate>Wed, 13 Oct 2021 22:29:37 +0000</pubDate><guid>/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</guid><description>缘起 最近在看《Java NIO》这本书，书中详细讲解了jdk1.4内提供的关于实现nio的API。因为阅读后，发现对于NIO还是学习的不够深入，之前也仅仅是学习了Java的文件IO和Socket编程，再</description></item><item><title>Java临时文件删除时注意的坑</title><link>/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link><pubDate>Tue, 05 Jan 2021 18:56:13 +0000</pubDate><guid>/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid><description>前言 最近在生产环境上发现了临时目录堆积吃掉大量磁盘的问题，最终原因是代码有Bug，异常后未执行delete file的代码或者执行了，但是删除失败。 解决思路 将删除文件的代码放到finally块中。 确保删</description></item><item><title>java之future异步并发体验</title><link>/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 11:36:48 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.mango.demo; import cn.hutool.http.HttpUtil; import com.google.common.collect.Lists; import com.google.common.util.concurrent.ListenableFuture; import com.google.common.util.concurrent.ListeningExecutorService; import com.google.common.util.concurrent.MoreExecutors; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.stream.Collectors;</description></item><item><title>java之forkjoin体验</title><link>/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 10:52:37 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码！ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.mango.forkjoin; import cn.hutool.http.HttpUtil; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.RecursiveTask; public class ServiceTask extends RecursiveTask&amp;lt;String&amp;gt; { private String url; public ServiceTask(String url){ this.url = url; } @Override protected String compute() { String result</description></item><item><title>java之深入jvm之路</title><link>/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</link><pubDate>Sat, 14 Dec 2019 14:45:07 +0000</pubDate><guid>/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</guid><description>1.仔细看一看java 1.1.java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaB</description></item><item><title>java日志门面</title><link>/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</link><pubDate>Sat, 14 Dec 2019 13:44:06 +0000</pubDate><guid>/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</guid><description>1.slf4j是什么 slf4j全称为Simple Logging Facade for Java ,即java简单日志门面，渐渐地替换调了apache common logging。 The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time. 理</description></item><item><title>Java性能注意点</title><link>/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</link><pubDate>Fri, 04 Nov 2016 15:56:32 +0000</pubDate><guid>/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</guid><description>参考：http://www.importnew.com/16181.html 1.stringBuilder.append 比 + 号的性能要优。 2.要避免使用正则表达式。 3.避免使用iterator迭代器来循环。尽量使用基本循环和增强for循环。 4</description></item></channel></rss>