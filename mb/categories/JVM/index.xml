<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on 程序猫大刚</title><link>/mb/categories/JVM/</link><description>Recent content in JVM on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 22 Aug 2022 22:40:21 +0800</lastBuildDate><atom:link href="/mb/categories/JVM/index.xml" rel="self" type="application/rss+xml"/><item><title>MacOs10.15.7编译openjdk8u</title><link>/mb/post/jvm/MacOs10.15.7%E7%BC%96%E8%AF%91openjdk8u/</link><pubDate>Mon, 22 Aug 2022 22:40:21 +0800</pubDate><guid>/mb/post/jvm/MacOs10.15.7%E7%BC%96%E8%AF%91openjdk8u/</guid><description>机器环境及依赖 操作系统：macOs 10.15.7 BootJDK: /Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home XCode：Version 11.3.1 (11C505) hg命令(mercurial): brew install mercurial freetype: brew install freetype 注意：笔者先前打算编译jdk8，一番折腾后各种报错，最后选择jdk8u的版本。 1.进</description></item><item><title>内存分配与回收策略</title><link>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</link><pubDate>Sat, 20 Aug 2022 10:36:03 +0800</pubDate><guid>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</guid><description>前提环境 笔者JDK版本如下，如果不做指定的话，64为虚拟机1.8版本默认使用的ParallelGC垃圾收集器。 $ java -XX:+PrintCommandLineFlags -version -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version &amp;quot;1.8.0_221&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 使用-XX:+UseSerialG</description></item><item><title>垃圾收集算法</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 20 Aug 2022 10:22:08 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</guid><description>分代收集理论 3个假说 弱分代假说：绝大多数对象都是朝生夕灭的。（设计了年轻代） 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。（设计了老年代） 跨代引用假说：跨代引用相对于同代引用仅占极少数。（实际</description></item><item><title>虚拟机相关工具</title><link>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 20 Aug 2022 09:40:53 +0800</pubDate><guid>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</guid><description>本文主要是为了介绍虚拟机相关的工具，包括故障处理、性能监控和一些其他工具。 故障处理工具 名称 全称 作用及描述 jps JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool 用于收集HotSpot虚拟机各方</description></item><item><title>回收堆和方法区中对象</title><link>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 12 Aug 2022 10:54:26 +0800</pubDate><guid>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，知道了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>Java发展历史</title><link>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</link><pubDate>Fri, 12 Aug 2022 10:30:06 +0800</pubDate><guid>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</guid><description>Java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaBeans，RMI。 1998年1</description></item><item><title>垃圾判定算法与4大引用</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</link><pubDate>Wed, 10 Aug 2022 22:13:41 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，指出了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>如何计算Java对象的大小</title><link>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</link><pubDate>Tue, 09 Aug 2022 18:11:01 +0800</pubDate><guid>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</guid><description>关键点 Java对象的布局结构 借助jol-core包来打印对象 引用的指针压缩 对象布局 Java对象布局（Java Object Layout） String对象例子 int[]数组对象例子 引用的指针压缩 JVM内存寻址最大内</description></item><item><title>熟悉HotSpot中的对象</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</link><pubDate>Tue, 09 Aug 2022 17:50:54 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</guid><description>对象的内存布局 在HotSpot虚拟机中，对象的内存布局分为以下3个区域： 对象头 实例数据 对齐填充 对象头 对象头包含Mark Word和类型指针2个部分。如果是数组对象，则有一部分存储数组的长度。 Mark Word中</description></item><item><title>深入类加载机制</title><link>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 08 Jul 2022 12:16:51 +0800</pubDate><guid>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>类的生命周期 加载 验证 文件格式验证，元数据验证（语义校验），字节码验证（逻辑校验），符号引用校验 准备 为类变量(static的）分配内存并赋初始值。 解析 主要针对： 类或接口：CONSTANT_Class_i</description></item></channel></rss>