<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on 程序猫大刚</title><link>/mb/categories/JVM/</link><description>Recent content in JVM on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 27 Sep 2022 23:27:02 +0800</lastBuildDate><atom:link href="/mb/categories/JVM/index.xml" rel="self" type="application/rss+xml"/><item><title>熟悉JVM内存区域</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Tue, 27 Sep 2022 23:27:02 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>Java运行时数据区 如下内容如未说明均以JDK1.7版本为准 JVM内存主要分为5个部分： 程序计数器 虚拟机栈 本地方法栈 堆 方法区 而JDK1.8和JDK1.7比，主要是将方法区（永久代） 被 元数据区取代，而且</description></item><item><title>HotSpot垃圾算法实现之并发的可达性分析</title><link>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90/</link><pubDate>Mon, 26 Sep 2022 22:37:18 +0800</pubDate><guid>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90/</guid><description>并发的可达性分析 根可达算法在理论上，需要冻结全部的用户线程运行。在根节点枚举步骤中，由于GC Roots相比整个Java堆中全部对象毕竟是极少数，且在OopMap优化下，带来的停顿时间非常短暂且相等固定</description></item><item><title>HotSpot垃圾算法实现之记忆集与卡表和写屏障</title><link>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C/</link><pubDate>Thu, 01 Sep 2022 18:45:53 +0800</pubDate><guid>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C/</guid><description>问题一：对象跨代（区域）引用，GC Roots扫描范围如何界定？ 当部分区域进行垃圾收集时，如果非收集区域的对象跨区引用了收集区域的对象（收集区域的对象A可能被非收集区域的对象静态字段B引用，这样对象A应</description></item><item><title>HotSpot垃圾算法实现之枚举根节点和安全点安全区域</title><link>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E7%82%B9%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/</link><pubDate>Thu, 01 Sep 2022 18:37:32 +0800</pubDate><guid>/mb/post/jvm/HotSpot%E5%9E%83%E5%9C%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E7%82%B9%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/</guid><description>在根可达性分析算法中，从GC Roots集合中找引用链是虚拟机高效实现的第一个例子。 问题一：为什么要枚举根节点？怎么高效实现？ 虽然GC Roots的节点主要在全局性的引用（例如常量或者类静态变量）与执行上</description></item><item><title>类加载器</title><link>/mb/post/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Thu, 01 Sep 2022 18:21:53 +0800</pubDate><guid>/mb/post/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>定义 Java虚拟机通过一个类的全限定名来获取类的二进制字节流的这个动作，放到虚拟机外部实现，让应用程序自己决定如何获取所需的类。 实现这个动作的代码叫做类加载器。 类与类加载器 每个类加载器都有自己独立的类</description></item><item><title>熟悉Java类文件class结构</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89Java%E7%B1%BB%E6%96%87%E4%BB%B6class%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 01 Sep 2022 00:27:48 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89Java%E7%B1%BB%E6%96%87%E4%BB%B6class%E7%BB%93%E6%9E%84/</guid><description>Java基于Class文件作为存储格式，不同平台对应虚拟机实现的方式让Java具备跨平台的特性。 因此我们有必要更深入学习Class字节码文件的结构。 Class文件的结构 Class文件是一组以8个字节为</description></item><item><title>熟悉JVM字节码指令</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</link><pubDate>Thu, 01 Sep 2022 00:19:31 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</guid><description>简介 Java虚拟机的指令由一个字节长度（256个操作码）的、代表着特定操作含义的数字（操作码，Opcode）和跟随其后的零至多个代表其操作需要的参数（操作数，Operand）构成。 由于Java虚拟机采</description></item><item><title>MacOs10.15.7编译openjdk8u</title><link>/mb/post/jvm/MacOs10_15_7%E7%BC%96%E8%AF%91openjdk8u/</link><pubDate>Mon, 22 Aug 2022 22:40:21 +0800</pubDate><guid>/mb/post/jvm/MacOs10_15_7%E7%BC%96%E8%AF%91openjdk8u/</guid><description>Mac10.15.7上编译OpenJDK8u 机器环境及依赖 操作系统：macOs 10.15.7 BootJDK: /Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home XCode：Version 11.3.1 (11C505) hg命令(mercurial): brew install mercurial freetype: brew install freetype 注意：笔者先前打算编译jdk8，一番折腾</description></item><item><title>内存分配与回收策略</title><link>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</link><pubDate>Sat, 20 Aug 2022 10:36:03 +0800</pubDate><guid>/mb/post/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</guid><description>前提环境 笔者JDK版本如下，如果不做指定的话，64为虚拟机1.8版本默认使用的ParallelGC垃圾收集器。 $ java -XX:+PrintCommandLineFlags -version -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version &amp;#34;1.8.0_221&amp;#34; Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 使用-XX:+UseSerialG</description></item><item><title>垃圾收集算法</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 20 Aug 2022 10:22:08 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</guid><description>分代收集理论 3个假说 弱分代假说：绝大多数对象都是朝生夕灭的。（设计了年轻代） 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。（设计了老年代） 跨代引用假说：跨代引用相对于同代引用仅占极少数。（实际</description></item><item><title>虚拟机相关工具</title><link>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 20 Aug 2022 09:40:53 +0800</pubDate><guid>/mb/post/jvm/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</guid><description>本文主要是为了介绍虚拟机相关的工具，包括故障处理、性能监控和一些其他工具。 故障处理工具 名称 全称 作用及描述 jps JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool 用于收集HotSpot虚拟机各方</description></item><item><title>回收堆和方法区中对象</title><link>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 12 Aug 2022 10:54:26 +0800</pubDate><guid>/mb/post/jvm/%E5%9B%9E%E6%94%B6%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AF%B9%E8%B1%A1/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，知道了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>Java发展历史</title><link>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</link><pubDate>Fri, 12 Aug 2022 10:30:06 +0800</pubDate><guid>/mb/post/jvm/Java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</guid><description>Java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaBeans，RMI。 1998年1</description></item><item><title>垃圾判定算法与4大引用</title><link>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</link><pubDate>Wed, 10 Aug 2022 22:13:41 +0800</pubDate><guid>/mb/post/jvm/%E5%9E%83%E5%9C%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B8%8E4%E5%A4%A7%E5%BC%95%E7%94%A8/</guid><description>哪些区域需要垃圾收集 在熟悉Java内存区域文中，指出了JVM运行时数据区有堆、方法区、虚拟机栈、本地方法栈和程序计数器5个部分，后3个部分都是线程私有的，其中的数据会跟随线程死亡自动回收，所以不需要垃</description></item><item><title>如何计算Java对象的大小</title><link>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</link><pubDate>Tue, 09 Aug 2022 18:11:01 +0800</pubDate><guid>/mb/post/jvm/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</guid><description>关键点 Java对象的布局结构 借助jol-core包来打印对象 引用的指针压缩 对象布局 Java对象布局（Java Object Layout） String对象例子 int[]数组对象例子 引用的指针压缩 JVM内存寻址最大内</description></item><item><title>熟悉HotSpot中的对象</title><link>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</link><pubDate>Tue, 09 Aug 2022 17:50:54 +0800</pubDate><guid>/mb/post/jvm/%E7%86%9F%E6%82%89HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</guid><description>对象的内存布局 在HotSpot虚拟机中，对象的内存布局分为以下3个区域： 对象头 实例数据 对齐填充 对象头 对象头包含Mark Word和类型指针2个部分。如果是数组对象，则有一部分存储数组的长度。 Mark Word中</description></item><item><title>深入类加载机制</title><link>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 08 Jul 2022 12:16:51 +0800</pubDate><guid>/mb/post/jvm/%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>类的生命周期 加载 验证 文件格式验证，元数据验证（语义校验），字节码验证（逻辑校验），符号引用校验 准备 为类变量(static的）分配内存并赋初始值。 解析 主要针对： 类或接口：CONSTANT_Class_i</description></item></channel></rss>