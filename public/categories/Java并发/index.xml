<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java并发 on 程序猫大刚</title><link>/mb/categories/Java%E5%B9%B6%E5%8F%91/</link><description>Recent content in Java并发 on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 28 Jul 2022 10:42:57 +0800</lastBuildDate><atom:link href="/mb/categories/Java%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>并发模式之异步回调Future模式</title><link>/mb/post/juc/11%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 10:42:57 +0800</pubDate><guid>/mb/post/juc/11%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</guid><description>Future模式（异步获取结果，自实现） 传统串行流程如下： 在获取数据时会阻塞等待，拿到数据后再执行其他的任务。 而Future模式会立即返回一个凭证（Future），这时可以执行其他任务；等需要数据再通</description></item><item><title>并发模式之异步回调Future模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 10:42:57 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83Future%E6%A8%A1%E5%BC%8F/</guid><description>Future模式（异步获取结果，自实现） 传统串行流程如下： 在获取数据时会阻塞等待，拿到数据后再执行其他的任务。 而Future模式会立即返回一个凭证（Future），这时可以执行其他任务；等需要数据再通</description></item><item><title>并发模式之生产者消费者模式</title><link>/mb/post/juc/10%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:54:19 +0800</pubDate><guid>/mb/post/juc/10%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>生产者 - 消费者模式 生产者消费者模式是一个经典的多线程设计模式。 总结： 生产者线程将任务提交到内存缓冲区，消费者线程从内存缓冲区获取任务并执行。 通过内存缓冲区，避免了生成者和消费者直接通信，从而将生产者和</description></item><item><title>并发模式之生产者消费者模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:54:19 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>生产者 - 消费者模式 生产者消费者模式是一个经典的多线程设计模式。 总结： 生产者线程将任务提交到内存缓冲区，消费者线程从内存缓冲区获取任务并执行。 通过内存缓冲区，避免了生成者和消费者直接通信，从而将生产者和</description></item><item><title>并发模式之单例和不变模式</title><link>/mb/post/juc/09%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:53:21 +0800</pubDate><guid>/mb/post/juc/09%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式是为了确保系统中某个类只存在一个实例。 在多种写法中，推荐使用静态内部类方式，利用类加载一次特性确保只有一个实例（线程安全）， 同时具备无锁和懒创建优点。 示例： public class StaticInnerClassSingleton { // 私有化构造方法 private StaticInnerClassSingleton(){}</description></item><item><title>并发模式之单例和不变模式</title><link>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 28 Jul 2022 09:53:21 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E5%92%8C%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式是为了确保系统中某个类只存在一个实例。 在多种写法中，推荐使用静态内部类方式，利用类加载一次特性确保只有一个实例（线程安全）， 同时具备无锁和懒创建优点。 示例： public class StaticInnerClassSingleton { // 私有化构造方法 private StaticInnerClassSingleton(){}</description></item><item><title>Java关键字synchronized</title><link>/mb/post/juc/07Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</link><pubDate>Sun, 24 Jul 2022 00:10:19 +0800</pubDate><guid>/mb/post/juc/07Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</guid><description>提纲 定义 synchronized是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。 特性 因为在synchronized同步块内，只有一个线程能访问，因此确保了同步块内的</description></item><item><title>Java关键字synchronized</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</link><pubDate>Sun, 24 Jul 2022 00:10:19 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97synchronized/</guid><description>提纲 定义 synchronized是同步块，实现了多线程间的互斥同步。它修饰的代码，确保任一时刻只有一个线程进入访问。 特性 因为在synchronized同步块内，只有一个线程能访问，因此确保了同步块内的</description></item><item><title>Java的线程实现</title><link>/mb/post/juc/08Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 20 Jul 2022 22:09:06 +0800</pubDate><guid>/mb/post/juc/08Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</guid><description>Java线程是如何实现的？ 当我们追踪Java线程的实现时，可以发现Thread类的start方法最后会运行一个start0方法，而这个方法是native的，也就是交由JDK来实现的（JDK会屏蔽调底层</description></item><item><title>Java的线程实现</title><link>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 20 Jul 2022 22:09:06 +0800</pubDate><guid>/mb/post/juc/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/</guid><description>Java线程是如何实现的？ 当我们追踪Java线程的实现时，可以发现Thread类的start方法最后会运行一个start0方法，而这个方法是native的，也就是交由JDK来实现的（JDK会屏蔽调底层</description></item><item><title>Java关键字之volatile</title><link>/mb/post/juc/06Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</link><pubDate>Tue, 19 Jul 2022 23:28:21 +0800</pubDate><guid>/mb/post/juc/06Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</guid><description>提纲 定义 语义上，volatile是表示易变的、不确定的。 功能上，是Java提供的最轻量级的同步机制。 前因：从CPU缓存架构类比JMM线程工作内存和主内存关系 要弄懂如何保证可见性的，请看下图，左侧是CP</description></item><item><title>Java关键字之volatile</title><link>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</link><pubDate>Tue, 19 Jul 2022 23:28:21 +0800</pubDate><guid>/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bvolatile/</guid><description>提纲 定义 语义上，volatile是表示易变的、不确定的。 功能上，是Java提供的最轻量级的同步机制。 前因：从CPU缓存架构类比JMM线程工作内存和主内存关系 要弄懂如何保证可见性的，请看下图，左侧是CP</description></item><item><title>Java多线程同步控制方法</title><link>/mb/post/juc/05Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 17 Jul 2022 16:44:52 +0800</pubDate><guid>/mb/post/juc/05Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</guid><description>关键字Synchronized 关键字Synchronized、Object.wat()和Object.notify()是在jdk1.5之前用的多线程同步控制的方式，jdk1.5之后就提供了如下的jav</description></item><item><title>Java多线程同步控制方法</title><link>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</link><pubDate>Sun, 17 Jul 2022 16:44:52 +0800</pubDate><guid>/mb/post/juc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/</guid><description>关键字Synchronized 关键字Synchronized、Object.wat()和Object.notify()是在jdk1.5之前用的多线程同步控制的方式，jdk1.5之后就提供了如下的jav</description></item><item><title>并行程序基础</title><link>/mb/post/juc/02%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 11 Jul 2022 11:49:35 +0800</pubDate><guid>/mb/post/juc/02%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid><description>程序、进程、线程 线程的生命周期 线程的状态图 线程的基本操作 线程组 守护线程 优先级 参考文档 书籍：葛一鸣 *《Java高并发程序设计第二版》</description></item><item><title>并行程序基础</title><link>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 11 Jul 2022 11:49:35 +0800</pubDate><guid>/mb/post/juc/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid><description>程序、进程、线程 线程的生命周期 线程的状态图 线程的基本操作 线程组 守护线程 优先级 参考文档 书籍：葛一鸣 *《Java高并发程序设计第二版》</description></item><item><title>熟悉Java内存模型JMM</title><link>/mb/post/juc/03%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</link><pubDate>Wed, 06 Jul 2022 11:22:04 +0800</pubDate><guid>/mb/post/juc/03%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</guid><description>Java内存模型规范（JSR-133）是围绕原子性、可见性和有序性展开的。 原子性、可见性、有序性 如下图说明了Java线程、工作内存和主存之前的关系。 Java内存模型（JMM）定义了一套自己的主存到工作</description></item><item><title>熟悉Java内存模型JMM</title><link>/mb/post/juc/%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</link><pubDate>Wed, 06 Jul 2022 11:22:04 +0800</pubDate><guid>/mb/post/juc/%E7%86%9F%E6%82%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</guid><description>Java内存模型规范（JSR-133）是围绕原子性、可见性和有序性展开的。 原子性、可见性、有序性 如下图说明了Java线程、工作内存和主存之前的关系。 Java内存模型（JMM）定义了一套自己的主存到工作</description></item><item><title>走入并行的世界</title><link>/mb/post/juc/01%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 01 Jul 2022 10:33:34 +0800</pubDate><guid>/mb/post/juc/01%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>走入并行的世界 这该死的并行 摩尔定律发展 一些基本概念 同步 vs 异步 并发 vs 并行 临界区 多个线程的公共资源，或者说共享数据。 阻塞 vs 非阻塞 死锁、饥饿、活锁 并发级别 并行加速比公式 参考文档 书籍：葛一鸣 *《Java高并发</description></item><item><title>走入并行的世界</title><link>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 01 Jul 2022 10:33:34 +0800</pubDate><guid>/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>走入并行的世界 这该死的并行 摩尔定律发展 一些基本概念 同步 vs 异步 并发 vs 并行 临界区 多个线程的公共资源，或者说共享数据。 阻塞 vs 非阻塞 死锁、饥饿、活锁 并发级别 并行加速比公式 参考文档 书籍：葛一鸣 *《Java高并发</description></item><item><title>线程池入门到精通</title><link>/mb/post/juc/04%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</link><pubDate>Tue, 28 Jun 2022 16:38:30 +0800</pubDate><guid>/mb/post/juc/04%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</guid><description>什么是线程池 复用创建好的线程，节约创建和销毁的时间。 需要使用线程时，就从池子里拿一个空闲的线程，完成工作后，归还线程给线程池。 线程池工作原理 线程池工作流程 线程池生命周期及扩展点 线程池参数 JDK提供的线</description></item><item><title>线程池入门到精通</title><link>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</link><pubDate>Tue, 28 Jun 2022 16:38:30 +0800</pubDate><guid>/mb/post/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</guid><description>什么是线程池 复用创建好的线程，节约创建和销毁的时间。 需要使用线程时，就从池子里拿一个空闲的线程，完成工作后，归还线程给线程池。 线程池工作原理 线程池工作流程 线程池生命周期及扩展点 线程池参数 JDK提供的线</description></item></channel></rss>