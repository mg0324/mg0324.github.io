<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 程序猫大刚</title><link>http://mg.meiflower.top/mb/tags/java/</link><description>Recent content in java on 程序猫大刚</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 05 Jul 2022 10:38:54 +0800</lastBuildDate><atom:link href="http://mg.meiflower.top/mb/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java关键字volatile</title><link>http://mg.meiflower.top/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97volatile/</link><pubDate>Tue, 05 Jul 2022 10:38:54 +0800</pubDate><guid>http://mg.meiflower.top/mb/post/juc/Java%E5%85%B3%E9%94%AE%E5%AD%97volatile/</guid><description>Java关键字volatile 提纲 定义 语义上，volatile是表示易变的、不确定的。 功能上，是Java提供的最轻量级的同步机制。 前因：从CPU缓存架构类比JMM线程工作内存和主内存关系 要弄懂如何保证</description></item><item><title>走入并行的世界</title><link>http://mg.meiflower.top/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 01 Jul 2022 10:33:34 +0800</pubDate><guid>http://mg.meiflower.top/mb/post/juc/%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>走入并行的世界 这该死的并行 摩尔定律发展 一些基本概念 同步 vs 异步 并发 vs 并行 临界区 多个线程的公共资源，或者说共享数据。 阻塞 vs 非阻塞 死锁、饥饿、活锁 并发级别 并行加速比公式</description></item><item><title>Java本地方法调用</title><link>http://mg.meiflower.top/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</link><pubDate>Tue, 24 May 2022 23:08:25 +0800</pubDate><guid>http://mg.meiflower.top/mb/post/java/java%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</guid><description>引子 Class.forName(&amp;quot;com.msql.jdbc.Driver&amp;quot;); 我们在加载mysql的jdbc驱动时，会主动加载对应的驱动类，然后使用DriverManager来获取连接操作数据库。 跟进forName的实现会发现是调用的native方法来实现的，也就是JNI</description></item><item><title>发布jar包公共maven仓库</title><link>http://mg.meiflower.top/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</link><pubDate>Sat, 25 Dec 2021 22:18:49 +0800</pubDate><guid>http://mg.meiflower.top/mb/post/java/%E5%8F%91%E5%B8%83jar%E5%8C%85%E5%85%AC%E5%85%B1maven%E4%BB%93%E5%BA%93/</guid><description>起因 自己写了个简单的框架，想要发布到公共的maven仓库上，方便自己引用，也给其他开发者创造一个轮子。 参考鸣谢 流程 https://blog.csdn.net/qq_36838191/article/details/81027586 操作 https://www.cnblogs.com/newsea/p/11604171.html 几个地址 工单管理: https://issues.sonatype.org 构件仓库: https://oss.sonatype.org/#welcome 仓库镜像: http://search.maven.org/ 发布流程 创建工单 发布jar包 审核通</description></item><item><title>从何而来之Java NIO</title><link>http://mg.meiflower.top/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</link><pubDate>Wed, 13 Oct 2021 22:29:37 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E4%B9%8BJava-NIO/</guid><description>缘起 最近在看《Java NIO》这本书，书中详细讲解了jdk1.4内提供的关于实现nio的API。因为阅读后，发现对于NIO还是学习的不够深入，之前也仅仅是学习了Java的文件IO和Socket编程，再</description></item><item><title>Java临时文件删除时注意的坑</title><link>http://mg.meiflower.top/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</link><pubDate>Tue, 05 Jan 2021 18:56:13 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/Java%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</guid><description>前言 最近在生产环境上发现了临时目录堆积吃掉大量磁盘的问题，最终原因是代码有Bug，异常后未执行delete file的代码或者执行了，但是删除失败。 解决思路 将删除文件的代码放到finally块中。 确保删</description></item><item><title>java之future异步并发体验</title><link>http://mg.meiflower.top/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 11:36:48 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/java%E4%B9%8Bfuture%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package org.mango.demo; import cn.hutool.http.HttpUtil; import com.google.common.collect.Lists; import com.google.common.util.concurrent.ListenableFuture; import com.google.common.util.concurrent.ListeningExecutorService; import com.google.common.util.concurrent.MoreExecutors; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.stream.Collectors;</description></item><item><title>java之forkjoin体验</title><link>http://mg.meiflower.top/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</link><pubDate>Fri, 06 Mar 2020 10:52:37 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/java%E4%B9%8Bforkjoin%E4%BD%93%E9%AA%8C/</guid><description>废话不多说，直接上代码！ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package org.mango.forkjoin; import cn.hutool.http.HttpUtil; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.concurrent.RecursiveTask; public class ServiceTask extends RecursiveTask&amp;lt;String&amp;gt; { private String url; public ServiceTask(String url){ this.url = url; } @Override protected String compute() { String result</description></item><item><title>java之深入jvm之路</title><link>http://mg.meiflower.top/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</link><pubDate>Sat, 14 Dec 2019 14:45:07 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/java%E4%B9%8B%E6%B7%B1%E5%85%A5jvm%E4%B9%8B%E8%B7%AF/</guid><description>1.仔细看一看java 1.1.java发展历史 1995年5月23 Oak语言更名为Java 1996年1月23 JDK 1.0发布 1997年2月19日JDK 1.1发布 技术代表：JDBC，JAR文件格式，JavaB</description></item><item><title>java日志门面</title><link>http://mg.meiflower.top/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</link><pubDate>Sat, 14 Dec 2019 13:44:06 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/java%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2/</guid><description>1.slf4j是什么 slf4j全称为Simple Logging Facade for Java ,即java简单日志门面，渐渐地替换调了apache common logging。 The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time. 理</description></item><item><title>Java性能注意点</title><link>http://mg.meiflower.top/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</link><pubDate>Fri, 04 Nov 2016 15:56:32 +0000</pubDate><guid>http://mg.meiflower.top/mb/post/java/Java%E6%80%A7%E8%83%BD%E6%B3%A8%E6%84%8F%E7%82%B9/</guid><description>参考：http://www.importnew.com/16181.html 1.stringBuilder.append 比 + 号的性能要优。 2.要避免使用正则表达式。 3.避免使用iterator迭代器来循环。尽量使用基本循环和增强for循环。 4</description></item></channel></rss>