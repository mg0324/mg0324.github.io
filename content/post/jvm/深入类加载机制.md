---
title: "深入类加载机制"
date: 2022-07-08T12:16:51+08:00
draft: false
categories: ["JVM"]
tags: ["java","jvm"]
---

## 类的生命周期

![](/mb/images/jvm2/classload/01.png)

## 加载

![](/mb/images/jvm2/classload/02.png)

## 验证
文件格式验证，元数据验证（语义校验），字节码验证（逻辑校验），符号引用校验

![](/mb/images/jvm2/classload/03.png)

## 准备
为类变量(static的）分配内存并赋初始值。

![](/mb/images/jvm2/classload/04.png)

## 解析
主要针对：
* 类或接口：CONSTANT_Class_info
* 字段：CONSTANT_Fieldref_info
* 类方法：CONSTANT_Methodref_info
* 接口方法：CONSTANT_InterfaceMethodref_info
(以下3种，是JDK1.7新增的动态语言支持，后续介绍）
* 方法类型：CONSTANT_MethodType_info
* 方法句柄：CONSTANT_MethodHandle_info
* 调用点限定符：CONSTANT_InvokeDynamic_info

![](/mb/images/jvm2/classload/05.png)
 
## 初始化

![](/mb/images/jvm2/classload/06.png)

![](/mb/images/jvm2/classload/07.png)

测试：
~~~
/**
 * 死循环类
 * @Author: mango
 * @Date: 2022/6/19 10:54 上午
 */
public class DeadLoopClass {
    static {
        if(true){
            System.out.println(Thread.currentThread() + " init DeadLoopClass");
            while (true){
                // 模拟长时间操作
            }
        }
    }
}
~~~
~~~
/**
 * 类加载及初始化测试
 * @Author: mango
 * @Date: 2022/6/19 10:58 上午
 */
public class ClassInitTest {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread() + " start");
                DeadLoopClass dlc = new DeadLoopClass();
                System.out.println(Thread.currentThread() + " end");
            }
        };
        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        t1.start();
        t2.start();
    }
}
/**
 * 结果：第一个线程会卡主，其他线程阻塞
 * Thread[Thread-0,5,main] start
 * Thread[Thread-1,5,main] start
 * Thread[Thread-0,5,main] init DeadLoopClass
 */

~~~

## 卸载
类卸载需要满足如下条件：(自定义类加载器加载的类才会被卸载)
* 该类所有的实例都已经被回收。
* 加载该类的ClassLoader已经被回收。
* 该类对应的java.lang.Class对象没有任何地方被引用。

